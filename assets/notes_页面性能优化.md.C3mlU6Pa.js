import{_ as l,c as i,o as a,a4 as e}from"./chunks/framework.Bn8BcnVb.js";const m=JSON.parse('{"title":"页面性能优化","description":"","frontmatter":{"title":"页面性能优化"},"headers":[],"relativePath":"notes/页面性能优化.md","filePath":"notes/页面性能优化.md"}'),t={name:"notes/页面性能优化.md"},r=e('<h1 id="页面性能优化" tabindex="-1">页面性能优化 <a class="header-anchor" href="#页面性能优化" aria-label="Permalink to &quot;页面性能优化&quot;">​</a></h1><h2 id="性能指标" tabindex="-1">性能指标 <a class="header-anchor" href="#性能指标" aria-label="Permalink to &quot;性能指标&quot;">​</a></h2><ul><li>FP 首次渲染时间，浏览器首次开始绘制任何内容</li><li>FCP 首次渲染第一个文本或图像的时间</li><li>LCP 绘制最大内容块的时间</li><li>TTI 用户可以开始与页面交互的时间</li><li>CLS 布局在加载过程的偏移距离，过高时布局会有突然移动的震动现象</li><li>FID 首次输入延迟，用户首次输入到浏览器响应的时间 根据业务场景我们重点关注的性能指标也不同，不过在大多数场景下FP和FCP的优化都是最重要的</li></ul><h2 id="页面渲染方式" tabindex="-1">页面渲染方式 <a class="header-anchor" href="#页面渲染方式" aria-label="Permalink to &quot;页面渲染方式&quot;">​</a></h2><p>客户端渲染<br> 优点：</p><ul><li>前后端分离，开发维护灵活</li><li>用户体验好</li></ul><p>缺点：</p><ul><li>首屏加载慢</li><li>SEO不友好</li><li>复杂度更高</li></ul><p>服务端渲染<br> 优点：</p><ul><li>首屏渲染更快</li><li>SEO效果好</li></ul><p>缺点：</p><ul><li>服务端压力大</li></ul><h2 id="cdn" tabindex="-1">CDN <a class="header-anchor" href="#cdn" aria-label="Permalink to &quot;CDN&quot;">​</a></h2><ul><li>缓存静态资源，降低服务器负担</li><li>使用负载均衡分流</li><li>根据主机就近节点进行内容分发，降低延迟</li><li>不需要传输cookie，提升传输效率</li><li>安全治理，防范DDos等攻击</li></ul><h2 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h2><ul><li>启用http2.0</li><li>使用http缓存</li><li>使用gzip</li></ul><h2 id="打包构建" tabindex="-1">打包构建 <a class="header-anchor" href="#打包构建" aria-label="Permalink to &quot;打包构建&quot;">​</a></h2><ul><li>压缩JS/CSS</li><li>去除冗余css</li><li>按需加载</li><li>异步或者延迟加载js</li><li>code splitting分割代码块 <ul><li>对于三方库一般不会经常变更，打包成单独文件长期使用缓存</li></ul></li><li>tree shaking</li><li>图片 <ul><li>尽量使用懒加载</li><li>使用data-url处理小图</li><li>使用字体图标</li><li>使用webp格式图片</li><li>使用svg替代位图</li><li>图片压缩</li><li>http1.1可以使用雪碧图减少请求数</li></ul></li></ul><h2 id="代码" tabindex="-1">代码 <a class="header-anchor" href="#代码" aria-label="Permalink to &quot;代码&quot;">​</a></h2><ul><li>js <ul><li>减少重排 <ul><li>缓存DOM计算属性</li></ul></li><li>长任务 <ul><li>不涉及DOM操作使用web worker</li><li>分片处理，拆分成子任务构建任务队列</li></ul></li><li>高频事件（resize、scroll、touchmove、wheel） <ul><li>使用节流防抖</li><li>调用requestAnimationFrame</li></ul></li><li>使用事件委托</li><li>接口返回慢 <ul><li>预加载接口</li></ul></li><li>接口数据如果很少变更且高频调用可以采用数据持久化方案</li></ul></li><li>css <ul><li>降低css选择器复杂度</li><li>使用过渡代替动画</li><li>启用合成层，强制开启GPU加速</li></ul></li><li>vue <ul><li>合理使用异步组件</li><li>使用keep-alive缓存组件</li><li>使用vuex或pinia缓存接口数据</li><li>使用计算属性缓存替换方法</li><li>使用函数式组件</li><li>合理选择v-if、v-show <ul><li>v-if首次加载更快，但是每次切换都会重新初始化组件，后续切换时渲染较慢</li><li>v-show首次就会加载所有分支组件，切换时只会重新渲染，不会更新组件</li></ul></li><li>复杂页面渲染卡顿 <ul><li>延迟加载组件，渐进式渲染，通过requsetFrameAnimation实现</li></ul></li><li>大数据场景，非必要时使用普通对象替换响应式数据，提升效率</li></ul></li></ul>',20),o=[r];function u(s,n,h,c,d,_){return a(),i("div",null,o)}const b=l(t,[["render",u]]);export{m as __pageData,b as default};
